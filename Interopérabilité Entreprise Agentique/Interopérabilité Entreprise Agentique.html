<!DOCTYPE html>
<html lang="fr" class="scroll-smooth dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L'Architecture des Systèmes Distribués à l'Ère Agentique</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Dark Mode - Slate & Sky Blue -->
    <!-- Application Structure Plan: The single-page thematic structure is retained but becomes even more critical with the expanded content. It prevents overwhelming the user with an excessively long page. The fixed sidebar navigation allows for immediate access to any core topic, facilitating its use as a detailed technical reference. This structure was chosen to manage the increased information density, allowing professionals to focus on specific areas of interest (e.g., AgentOps, PQC) without losing the overall context of the report. Interactions (clickable patterns, chart) are preserved to break up the dense text and provide dynamic points of engagement. -->
    <!-- Visualization & Content Choices: The bar chart comparing architectural paradigms is kept as the central visual anchor, as its purpose is comparative analysis, which benefits from visual representation. Its data and presentation are now adapted for a dark theme. The interactive cards for EIP and Agent patterns are expanded with more detailed descriptions and justifications, making them richer informational components. This approach maintains a balance between in-depth textual content and interactive elements, ensuring the application is both a comprehensive document and an exploratory tool, without resorting to static SVG/Mermaid diagrams. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .nav-link {
            transition: all 0.2s ease-in-out;
            border-left: 3px solid transparent;
        }
        .nav-link.active {
            border-left-color: #38bdf8;
            background-color: #1e293b;
            color: #7dd3fc;
            font-weight: 500;
        }
        .nav-link:hover {
            background-color: #334155;
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .pattern-card {
            cursor: pointer;
        }
        .pattern-detail {
             max-height: 0;
             overflow: hidden;
             transition: max-height 0.5s ease-in-out, margin-top 0.5s ease-in-out, opacity 0.5s;
             opacity: 0;
        }
        .pattern-card.open .pattern-detail {
            max-height: 500px;
            margin-top: 1rem;
            opacity: 1;
        }
        .pattern-card.open .arrow-indicator {
            transform: rotate(180deg);
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 400px;
            max-height: 50vh;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 450px;
            }
        }
    </style>
</head>
<body class="antialiased bg-slate-900 text-slate-300">

    <div class="relative min-h-screen md:flex">
        <div id="mobile-nav" class="bg-slate-800 text-slate-100 flex justify-between md:hidden sticky top-0 z-20 shadow-lg">
            <a href="#" class="block p-4 text-sky-400 font-bold">Menu</a>
            <button id="mobile-menu-button" class="p-4 focus:outline-none focus:bg-slate-700">
                <svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
            </button>
        </div>

        <aside id="sidebar" class="bg-slate-800 text-slate-200 w-64 space-y-6 py-7 px-2 absolute inset-y-0 left-0 transform -translate-x-full md:relative md:translate-x-0 transition duration-200 ease-in-out z-30 shadow-2xl md:shadow-none">
            <div class="px-4">
                <h2 class="text-xl font-bold text-sky-400">Architectures Distribuées</h2>
                <p class="text-xs text-slate-400 mt-1">L'Ère Agentique (Version Bonifiée)</p>
            </div>
            <nav id="main-nav">
                <a href="#introduction" class="nav-link block py-2.5 px-4 rounded">Introduction</a>
                <a href="#fondations" class="nav-link block py-2.5 px-4 rounded">1. Fondations Asynchrones</a>
                <a href="#kafka" class="nav-link block py-2.5 px-4 rounded">2. Le Système Nerveux (Kafka)</a>
                <a href="#paradigme" class="nav-link block py-2.5 px-4 rounded">3. Le Paradigme Agentique</a>
                <a href="#ingenierie" class="nav-link block py-2.5 px-4 rounded">4. Ingénierie des Agents</a>
                <a href="#gouvernance" class="nav-link block py-2.5 px-4 rounded">5. Gouvernance (AgentOps)</a>
                <a href="#horizons" class="nav-link block py-2.5 px-4 rounded">6. Horizons Futurs</a>
                 <a href="#conclusion" class="nav-link block py-2.5 px-4 rounded">Conclusion</a>
            </nav>
        </aside>

        <main class="flex-1 p-6 sm:p-8 lg:p-12 bg-slate-900">
            <div id="content-container">
            </div>
        </main>
    </div>

    <script>
        const contentData = {
            introduction: {
                title: "Introduction : De la Gestion de la Complexité à la Délégation de l'Autonomie",
                content: `
                    <p class="mb-4 text-lg text-slate-300">Les architectures logicielles modernes sont confrontées à un défi central : une augmentation insoutenable de la complexité. De l'architecture monolithique, simple à concevoir mais rigide et difficile à faire évoluer, nous sommes passés à l'ère des microservices, une promesse de modularité et d'agilité. Cependant, chaque paradigme, en résolvant un problème, a introduit une nouvelle forme de complexité. Les microservices ont fragmenté la complexité du monolithe en un "spaghetti distribué", créant un nouveau fardeau pour les équipes : la <strong>dette cognitive architecturale</strong>. Cette charge mentale, nécessaire pour comprendre, maintenir et faire évoluer un réseau enchevêtré de services indépendants communiquant sur un réseau intrinsèquement peu fiable, est devenue le principal frein à l'innovation.</p>
                    <p class="mb-4 text-slate-400">La dette cognitive se manifeste concrètement par un temps de montée en compétence excessif pour les nouveaux développeurs, une difficulté à diagnostiquer les défaillances en cascade, et une paralysie face à toute modification systémique par peur des effets de bord imprévus. Elle transforme l'agilité promise en une rigidité distribuée.</p>
                    <p class="mb-4 text-slate-300">Face à cet impératif d'adaptabilité dans un monde VUCA (Volatil, Incertain, Complexe, Ambigu), l'entreprise agentique n'est pas une simple amélioration, mais une réponse structurelle. Elle propose un changement de paradigme fondamental : au lieu de tenter de maîtriser une complexité toujours croissante, nous devons la <strong>déléguer</strong>. Le principe est de passer de la construction de systèmes qui exécutent des flux de travail rigides à la culture d'un écosystème d'entités autonomes — les agents — capables de percevoir leur environnement, de raisonner et d'agir pour atteindre des objectifs. Cette délégation n'est pas un détail technique ; elle signale une évolution fondamentale de notre profession, de la construction de machines rigides à la culture d'écosystèmes numériques vivants.</p>
                     <p class="text-slate-400">Ce document a pour vocation de guider l'architecte et le décideur à travers cette transformation. Nous commencerons par les fondations de la communication asynchrone qui rendent cette autonomie possible, nous explorerons ensuite comment des plateformes comme Apache Kafka forment le système nerveux de l'entreprise, pour enfin plonger au cœur du paradigme agentique, de ses modèles de conception à sa gouvernance opérationnelle, jusqu'aux frontières de l'informatique quantique.</p>
                `
            },
            fondations: {
                title: "Les Fondations de l'Intégration Asynchrone : Les Modèles EIP",
                intro: "Cette section explore les principes fondamentaux qui permettent de construire des systèmes distribués résilients et évolutifs. En se basant sur la communication asynchrone et les Modèles d'Intégration d'Entreprise (EIP), nous posons les bases nécessaires pour comprendre comment des composants indépendants peuvent collaborer efficacement sans être étroitement liés. Il s'agit d'une condition sine qua non pour l'autonomie des agents, car l'autonomie véritable ne peut exister sans un découplage temporel et spatial robuste.",
                sections: [
                    {
                        subtitle: "1.1 Le Découplage comme Principe Fondamental",
                        content: `<p>Dans les systèmes distribués, le couplage lâche (ou faible) n'est pas une simple bonne pratique, c'est un impératif stratégique. Les architectures basées sur des appels de procédure à distance (RPC) synchrones créent des dépendances temporelles fortes : si un service est indisponible ou lent, l'ensemble du système en cascade peut être affecté. La communication asynchrone via des systèmes de messagerie brise cette dépendance. En plaçant un message dans une file d'attente, l'émetteur n'a plus besoin d'attendre la réponse du récepteur ; il peut continuer son travail, sachant que le message sera traité ultérieurement. Ce découplage temporel confère au système une résilience et une évolutivité bien supérieures, car les composants peuvent fonctionner, échouer et être mis à l'échelle de manière indépendante.</p>`
                    },
                    {
                        subtitle: "1.2 Anatomie d'un Système de Messagerie",
                        content: `<p class="mb-4">Les capacités de messagerie sont fournies par un système logiciel spécialisé appelé Message-Oriented Middleware (MOM). Son rôle est de gérer et de coordonner l'envoi et la réception de messages de manière fiable. Ses composants fondamentaux sont les suivants :</p>
                        <ul class="list-disc list-inside space-y-3 text-slate-300">
                            <li><strong>Le Message :</strong> Une structure de données atomique composée d'un <em>en-tête (header)</em> contenant des métadonnées pour le routage et le traitement (ex: ID de corrélation, destination, priorité) et d'un <em>corps (body)</em>, qui contient la charge utile (payload) applicative. Le format de la charge utile (JSON, XML, Protobuf) est un contrat entre le producteur et le consommateur.</li>
                            <li><strong>Les Canaux de Messagerie :</strong> conduits virtuels par lesquels les messages transitent. Les deux modèles principaux sont :
                               <ul class="list-['-_'] list-inside ml-6 mt-2 space-y-1">
                                   <li><strong>Canal Point à Point (File d'attente) :</strong> Garantit qu'un message n'est traité qu'une seule fois par un seul consommateur, même si plusieurs sont à l'écoute. Idéal pour les files de travail (work queues) où chaque tâche doit être exécutée exactement une fois.</li>
                                   <li><strong>Canal de Publication-Abonnement (Topic) :</strong> Diffuse une copie de chaque message à tous les consommateurs abonnés. C'est le modèle de base pour la notification d'événements et les architectures événementielles.</li>
                               </ul>
                            </li>
                            <li><strong>Le Message Endpoint :</strong> Le composant qui fait le pont entre le code applicatif et l'infrastructure de messagerie. Il encapsule la logique de connexion, de sérialisation/désérialisation, et de gestion des erreurs, présentant une interface simple à l'application.</li>
                        </ul>`
                    },
                    {
                        subtitle: "1.3 Modèles de Routage et de Transformation Essentiels (EIP)",
                        content: `
                            <p class="mb-4">Une fois les messages en circulation, il est nécessaire de les acheminer, de les filtrer et de les transformer. Les Enterprise Integration Patterns (EIP) cataloguent des solutions éprouvées pour ces tâches. Cliquez sur chaque modèle pour une explication détaillée.</p>
                            <div id="eip-patterns" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
                        `
                    },
                     {
                        subtitle: "1.4 Fiabilité et Corrélation",
                        content: `<p class="mb-4">Deux modèles sont cruciaux pour garantir la robustesse des communications dans un environnement distribué hostile.</p>
                        <div class="space-y-4">
                            <div class="p-4 bg-slate-800 rounded-lg border border-slate-700">
                                <h4 class="font-semibold text-sky-400">Guaranteed Delivery (Livraison Garantie)</h4>
                                <p class="text-sm text-slate-400 mt-1">Pour s'assurer qu'aucun message n'est perdu, ce modèle utilise un magasin de données persistant (souvent sur disque). Un message n'est supprimé du magasin de l'expéditeur qu'après avoir été transféré et stocké en toute sécurité dans le magasin du prochain maillon de la chaîne. Ceci est souvent implémenté via des accusés de réception (acknowledgements) du consommateur. Le modèle <a href="#" class="text-sky-500 hover:underline">Transactional Outbox</a> est une implémentation avancée qui garantit l'atomicité entre une modification de base de données et la publication d'un message correspondant.</p>
                            </div>
                            <div class="p-4 bg-slate-800 rounded-lg border border-slate-700">
                                <h4 class="font-semibold text-sky-400">Correlation Identifier (Identifiant de Corrélation)</h4>
                                <p class="text-sm text-slate-400 mt-1">Dans les interactions asynchrones de type requête-réponse, il est essentiel de pouvoir lier une réponse au message de requête initial. Le Correlation Identifier est un identifiant unique (ex: UUID), généré par le demandeur et placé dans l'en-tête du message de requête. Le récepteur copie cet identifiant dans l'en-tête du message de réponse, permettant ainsi au demandeur de faire correspondre sans ambiguïté la réponse à la bonne requête en attente parmi potentiellement des milliers.</p>
                            </div>
                        </div>
                        `
                    }
                ],
                patterns: [
                    { name: "Message Router", description: "Ce modèle examine le contenu ou les en-têtes d'un message pour le diriger dynamiquement vers le canal de destination approprié. <strong>Exemple :</strong> un système de traitement de commandes pourrait router les commandes vers <code>canal_commandes_urgentes</code> si le champ <code>priorité</code> est 'élevée', et vers <code>canal_commandes_standard</code> sinon." },
                    { name: "Message Filter", description: "Il est placé sur un canal et élimine les messages qui ne sont pas pertinents pour les consommateurs en aval, optimisant les ressources. <strong>Exemple :</strong> un service de notification d'inventaire pourrait filtrer tous les messages de mise à jour de stock qui ne concernent pas des produits dont le niveau est inférieur à un seuil critique." },
                    { name: "Recipient List", description: "Ce modèle permet de router un message unique vers une liste de destinataires qui peut être déterminée dynamiquement au moment du traitement. <strong>Exemple :</strong> lors d'une transaction financière suspecte, un message de notification est envoyé simultanément au service client, à l'équipe de conformité et au système de gestion des fraudes." },
                    { name: "Aggregator", description: "L'agrégateur est un composant avec état qui collecte et stocke une série de messages corrélés jusqu'à ce qu'une condition de complétude soit atteinte, puis les combine en un seul message. <strong>Exemple :</strong> un service de réservation de voyage attend de recevoir les confirmations de vol, d'hôtel et de location de voiture (corrélées par un ID de voyage) avant d'envoyer un itinéraire complet au client." },
                    { name: "Routing Slip", description: "Dans ce modèle, la séquence des étapes de traitement est attachée au message lui-même, souvent sous forme de liste d'adresses de canaux. Chaque composant, après traitement, consulte le 'bordereau' pour déterminer la prochaine destination. <strong>Exemple :</strong> un processus d'approbation de document doit passer séquentiellement par les services <code>juridique_approbation</code>, <code>financier_approbation`, puis <code>direction_approbation</code>." },
                    { name: "Claim Check", description: "Pour éviter de surcharger le système de messagerie avec des charges utiles volumineuses, ce modèle stocke les données dans un magasin externe (ex: S3, base de données) et ne fait circuler qu'un 'ticket de réclamation' (une référence ou un ID) dans le message. Le consommateur final utilise ce ticket pour récupérer les données complètes. <strong>Exemple :</strong> transmettre une référence à un fichier vidéo de 2 Go plutôt que la vidéo elle-même." }
                ]
            },
            kafka: {
                title: "Le Système Nerveux Central : Le Streaming de Données avec Apache Kafka",
                intro: "Cette section présente Apache Kafka non pas comme une simple file d'attente, mais comme un journal de transactions distribué, immuable et répliqué, qui forme la colonne vertébrale de l'entreprise moderne. Nous verrons comment son architecture 'log-centrique', son écosystème robuste et ses capacités de traitement en temps réel en font la plateforme idéale pour transporter, stocker et traiter l'information nécessaire aux systèmes agentiques, agissant comme une source de vérité unique et chronologique.",
                sections: [
                    {
                        subtitle: "2.1 Kafka : Au-delà d'une Simple File d'Attente",
                        content: `<p>Percevoir Kafka comme un simple MOM est une erreur stratégique fondamentale. Il doit être appréhendé comme un <strong>journal de transactions distribué et immuable</strong> (distributed commit log). Chaque événement, une fois écrit dans une partition, y reçoit un numéro de séquence (offset) et est ajouté de manière séquentielle. Il ne peut être ni modifié ni supprimé (dans les limites de la politique de rétention). Cette architecture 'log-centrique' positionne Kafka comme une source de vérité unique et chronologique pour l'ensemble du système d'information. Ce paradigme est stratégique : il permet de construire des systèmes intrinsèquement auditables, où l'état complet du système peut être reconstruit à tout moment en rejouant les événements depuis le début (Event Sourcing).</p>`
                    },
                    {
                        subtitle: "2.2 Concepts Fondamentaux de Kafka",
                        content: `<div class="bg-slate-800 border-l-4 border-sky-500 p-4 rounded-r-lg">
                            <ul class="space-y-4">
                                <li><p><strong class="text-sky-400">Record (Enregistrement) :</strong> L'unité de donnée atomique, composée d'une <em>clé (key)</em> (cruciale pour le partitionnement et la sémantique des données), d'une <em>valeur (value)</em> (la charge utile), d'<em>en-têtes (headers)</em> pour les métadonnées, et d'un <em>timestamp</em>.</p></li>
                                <li><p><strong class="text-sky-400">Topic :</strong> Un journal d'enregistrements nommé, qui est lui-même divisé en plusieurs <em>partitions</em>. Chaque partition est un journal ordonné et immuable.</p></li>
                                <li><p><strong class="text-sky-400">Partitioning :</strong> La clé (key) d'un enregistrement détermine sa partition via une fonction de hachage (par défaut 'murmur2'). Toutes les clés identiques sont garanties d'arriver sur la même partition. Ce mécanisme est le fondement de la scalabilité horizontale (en ajoutant des consommateurs et des partitions) et de l'ordonnancement (garanti au sein d'une partition).</p></li>
                                 <li><p><strong class="text-sky-400">Consumer Group :</strong> Un ou plusieurs consommateurs qui collaborent pour traiter un topic. Kafka distribue les partitions du topic entre les consommateurs du groupe, assurant que chaque partition n'est lue que par un seul membre du groupe à un instant T.</p></li>
                            </ul>
                        </div>`
                    },
                     {
                        subtitle: "2.3 L'Écosystème Kafka Connect",
                        content: `<p>Kafka Connect est un framework robuste et scalable pour intégrer de manière fiable Kafka avec des systèmes de données externes. Il opère en mode distribué et gère automatiquement le parallélisme, les offsets et la tolérance aux pannes, sans nécessiter de code personnalisé.</p>
                        <ul class="list-disc list-inside mt-3 space-y-2">
                          <li><strong>Source Connectors :</strong> Agissent comme des producteurs. Ils extraient des données de systèmes sources (bases de données relationnelles via JDBC, files d'attente MQTT, API REST) et les publient dans des topics Kafka.</li>
                          <li><strong>Sink Connectors :</strong> Agissent comme des consommateurs. Ils lisent les données des topics Kafka et les chargent dans des systèmes de destination (data warehouses comme Snowflake, moteurs de recherche comme Elasticsearch, bases de données NoSQL comme MongoDB).</li>
                          <li class="mt-2">Le <strong>Change Data Capture (CDC)</strong> est une application particulièrement puissante. Des outils comme Debezium lisent les journaux de transactions des bases de données (ex: WAL de PostgreSQL) pour capturer les changements au niveau des lignes (INSERT, UPDATE, DELETE) en temps réel et les transformer en un flux d'événements dans Kafka, sans impacter la performance de la base source.</li>
                        </ul>`
                    },
                    {
                        subtitle: "2.4 Traitement de Flux en Temps Réel avec Kafka Streams",
                        content: `<p class="mb-4">Kafka Streams est une bibliothèque client légère qui permet de construire des applications et des microservices de traitement de flux directement en Java ou Scala, en utilisant Kafka comme unique dépendance. Elle offre une API de haut niveau (DSL) et une API de bas niveau (Processor API).</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="p-4 bg-slate-800 rounded-lg">
                                <h4 class="font-semibold text-slate-100">Opérations sans état (Stateless)</h4>
                                <p class="text-sm text-slate-400">Transformations qui s'appliquent à chaque enregistrement individuellement, sans dépendre des enregistrements précédents. Exemples : <code>map</code>, <code>filter</code>, <code>flatMap</code>.</p>
                            </div>
                            <div class="p-4 bg-slate-800 rounded-lg">
                                <h4 class="font-semibold text-slate-100">Opérations avec état (Stateful)</h4>
                                <p class="text-sm text-slate-400">Opérations qui effectuent des calculs sur plusieurs événements et nécessitent de maintenir un état (stocké localement dans RocksDB et sauvegardé dans Kafka). Exemples : <code>count</code>, <code>aggregate</code>, <code>reduce</code>, <code>join</code>.</p>
                            </div>
                        </div>
                        <p class="mt-4">Kafka Streams supporte nativement la notion de temps (temps de l'événement, temps de traitement), le fenêtrage (tumbling, hopping, session windows) et la gestion des événements tardifs via une "période de grâce" (grace period).</p>`
                    }
                ]
            },
            paradigme: {
                title: "Le Paradigme Agentique : L'Évolution des Microservices",
                intro: "Ici, nous abordons le cœur du sujet : le passage des microservices à l'Agent Mesh. Cette section analyse les limites des architectures actuelles, notamment la 'dette cognitive', et définit ce qu'est un agent IA. L'objectif est de comprendre pourquoi l'Agent Mesh n'est pas une simple amélioration, mais une évolution nécessaire qui remplace la logique applicative rigide et impérative par une logique comportementale dynamique et orientée objectif.",
                sections: [
                    {
                        subtitle: "3.1 Les Limites des Microservices et l'Émergence de la Dette Cognitive",
                        content: `<p>La transition de l'architecture monolithique vers les microservices a été motivée par la promesse de la modularité. Cependant, cette indépendance a eu un coût : la complexité, autrefois contenue dans une seule base de code, a explosé pour devenir une complexité distribuée. La communication réseau, la résilience face aux pannes partielles, la découverte de services, la traçabilité et l'observabilité sont devenues des défis majeurs. Cette prolifération de dépendances et de points de défaillance potentiels a créé ce que l'on nomme la <strong>Dette Cognitive Architecturale</strong> : le fardeau mental écrasant imposé aux équipes pour simplement comprendre comment le système fonctionne dans son ensemble, le maintenir et le faire évoluer.</p>`
                    },
                    {
                        subtitle: "3.2 Définition et Principes de l'IA Agentique",
                        content: `
                        <p class="mb-2">L'IA agentique représente une évolution au-delà de l'IA générative. Alors que l'IA générative produit du contenu (texte, image), l'IA agentique produit des <strong>actions</strong>. Elle se définit par sa capacité à agir de manière autonome pour atteindre des objectifs.</p>
                        <p class="mb-4">Le cycle <strong>perception-raisonnement-action</strong> est au cœur de chaque agent. Il perçoit son environnement (via des événements Kafka, des appels d'API), raisonne pour décider de la meilleure action à entreprendre en fonction de ses objectifs, puis agit en conséquence (en publiant un événement, en appelant un outil).</p>
                        <p class="mb-2">Issus de la recherche sur les systèmes multi-agents (SMA), les agents possèdent des propriétés fondamentales :</p>
                        <ul class="list-disc list-inside space-y-2">
                           <li><strong>Autonomie :</strong> Un agent opère sans intervention humaine directe, contrôlant ses propres actions et son état interne. Il décide *quand* agir.</li>
                           <li><strong>Proactivité :</strong> Un agent ne se contente pas de réagir ; il prend des initiatives pour atteindre ses objectifs. Il est orienté but (*goal-driven*).</li>
                           <li><strong>Sociabilité :</strong> Un agent peut interagir avec d'autres agents (humains ou artificiels) en utilisant un langage de communication (ex: KQML, FIPA-ACL) pour coopérer, négocier ou se coordonner.</li>
                        </ul>`
                    },
                    {
                        subtitle: "3.3 L'Agent Mesh : Une Évolution Cognitive des Microservices",
                        content: `
                        <p class="mb-4">L'Agent Mesh (Maillage Agentique) est l'évolution logique du paradigme des microservices. Il conserve le principe de décomposition du système en composants indépendants, mais remplace la "logique applicative" statique d'un microservice par une "logique comportementale" dynamique d'un agent. L'architecte ne code plus des flux impératifs (<code>if/then/else</code>), mais conçoit des entités autonomes capables de décider de leurs propres actions pour atteindre un objectif donné.</p>
                        <div class="chart-container">
                            <canvas id="paradigmChart"></canvas>
                        </div>
                        `
                    },
                    {
                        subtitle: "3.4 Modèles de Coordination pour l'Intelligence Collective",
                        content: `<p class="mb-4">Dans un système multi-agents, l'intelligence globale émerge de la manière dont les agents se coordonnent. Trois approches existent :</p>
                        <div class="space-y-4">
                            <div class="p-4 border rounded-lg border-slate-700">
                                <h4 class="font-bold text-slate-100">Orchestration (Centralisée)</h4>
                                <p class="text-sm text-slate-400">Un "chef d'orchestre" (un agent ou un service dédié) dicte la séquence des interactions, appelant chaque agent/service dans un ordre prédéfini. Ce modèle est prévisible et facile à suivre, mais il crée un point de défaillance unique, un goulot d'étranglement, et est rigide face au changement.</p>
                            </div>
                            <div class="p-4 border rounded-lg border-slate-700">
                                <h4 class="font-bold text-slate-100">Chorégraphie (Décentralisée)</h4>
                                <p class="text-sm text-slate-400">Il n'y a pas de contrôleur central. Chaque agent réagit de manière autonome aux événements qui se produisent dans le système (par exemple, un événement "CommandeCréée" publié sur un bus de messages). Ce modèle favorise un couplage faible et une grande flexibilité. Cependant, la logique métier globale devient implicite et difficile à observer ou à déboguer.</p>
                            </div>
                            <div class="p-4 border-2 border-sky-500 rounded-lg bg-slate-800">
                                <h4 class="font-bold text-sky-400">La Stigmergie comme modèle supérieur</h4>
                                <p class="text-sm text-slate-300">La stigmergie est une forme avancée et puissante de chorégraphie. L'analogie la plus célèbre est celle de la colonie de fourmis. Les fourmis ne communiquent pas directement entre elles. Lorsqu'une fourmi trouve de la nourriture, elle dépose une trace de phéromones sur le chemin du retour. D'autres fourmis, en percevant cette trace, sont incitées à suivre la piste, renforçant ainsi le signal. Dans une entreprise numérique, les événements persistants dans Kafka agissent comme des "phéromones numériques". Un agent publie un événement qui modifie l'environnement informationnel, et d'autres agents perçoivent ce changement et y réagissent de manière autonome, créant une coordination émergente, hautement scalable et adaptative.</p>
                            </div>
                        </div>`
                    }
                ]
            },
             ingenierie: {
                title: "Ingénierie des Agents Intelligents : Modèles de Conception et Implémentation",
                intro: "Construire des agents robustes, fiables et performants ne se résume pas à écrire un unique prompt complexe. Cette section présente une boîte à outils de modèles de conception (design patterns) essentiels. Nous verrons comment décomposer des problèmes complexes, structurer le raisonnement d'un agent, l'outiller pour agir sur le monde réel, gérer sa mémoire à court et long terme, et intégrer une supervision humaine indispensable pour garantir la sécurité et la fiabilité.",
                sections: [
                    {
                        subtitle: "4.1 L'Importance des Modèles de Conception pour les Agents",
                        content: `<p>Tenter de résoudre une tâche à multiples facettes avec une seule instruction massive est inefficace et sujet aux erreurs : le modèle peut ignorer une partie des instructions, perdre le contexte initial ou propager des erreurs précoces. Les modèles de conception pour agents sont donc essentiels. Ils fournissent une boîte à outils de stratégies éprouvées pour décomposer des problèmes, structurer le raisonnement, outiller l'action et gérer le contexte, transformant des prompts fragiles en processus robustes.</p>`
                    },
                    {
                        subtitle: "4.2 Modèles pour le Raisonnement et l'Exécution",
                        content: `<p class="mb-4">Ces modèles fondamentaux structurent le comportement d'un agent pour résoudre des tâches complexes. Cliquez pour explorer.</p>
                        <div id="agent-patterns" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>`
                    },
                    {
                        subtitle: "4.3 Gestion de la Mémoire et du Contexte",
                        content: `
                        <p class="mb-4">Pour qu'un agent puisse maintenir une conversation cohérente et offrir des interactions personnalisées, il doit être doté de mémoire. La gestion de la mémoire est un des défis majeurs de l'ingénierie agentique.</p>
                        <div class="space-y-4">
                            <div>
                                <h4 class="font-semibold text-lg text-slate-100">Mémoire à Court Terme</h4>
                                <p class="text-slate-400">Le contexte de la conversation (l'historique des échanges récents) agit comme une mémoire à court terme. Il est directement injecté dans le prompt à chaque tour de conversation. Cependant, la taille de cette fenêtre de contexte est limitée par le modèle de langage (ex: 4k, 32k, 128k tokens), ce qui restreint la capacité de cette mémoire.</p>
                            </div>
                            <div class="p-4 bg-slate-800 border-l-4 border-emerald-500 rounded-r-lg">
                                <h4 class="font-semibold text-lg text-emerald-400">Mémoire à Long Terme (RAG)</h4>
                                <p class="mb-2 text-slate-300">Le modèle <strong>Retrieval-Augmented Generation (RAG)</strong> est le principal mécanisme de mémoire à long terme pour les agents. D'un point de vue architectural, il constitue la défense principale contre les hallucinations des LLM. En ancrant les réponses de l'agent dans une "source de vérité" externe, fiable et vérifiable (une base de connaissances, des documents), ce modèle garantit la précision factuelle.</p>
                                <p class="text-slate-400"><strong>Processus détaillé :</strong> 1. <strong>Indexation (Offline) :</strong> Les documents sont découpés (chunking), transformés en vecteurs numériques (embeddings) via un modèle d'encodage, et stockés dans une base de données vectorielle. 2. <strong>Récupération (Runtime) :</strong> La question de l'utilisateur est également transformée en vecteur. Le système effectue une recherche de similarité (ex: cosinus) dans la base vectorielle pour trouver les extraits les plus pertinents. 3. <strong>Génération Augmentée :</strong> Ces extraits pertinents sont injectés dans le prompt final du LLM avec la question originale, pour formuler une réponse basée sur ces informations.</p>
                            </div>
                        </div>
                        `
                    },
                    {
                        subtitle: "4.4 L'Indispensable Supervision : Le Modèle Human-in-the-Loop (HITL)",
                        content: `<p>La pleine autonomie n'est ni toujours possible, ni toujours souhaitable, en particulier dans les domaines critiques (finance, santé, sécurité). Le modèle <strong>Human-in-the-Loop (HITL)</strong> est une stratégie de conception délibérée qui intègre le jugement humain à des points de contrôle clés. L'agent peut être programmé pour solliciter une validation humaine avant d'exécuter une action à fort impact, pour demander de l'aide lorsqu'il rencontre une situation ambiguë, ou pour permettre à un superviseur de corriger sa trajectoire. Le HITL garantit la sécurité, l'alignement éthique et la robustesse du système, en combinant le meilleur de l'intelligence artificielle et de la cognition humaine.</p>`
                    }
                ],
                patterns: [
                    { name: "Prompt Chaining", description: "Incarne le principe 'diviser pour régner'. Un problème complexe est décomposé en une séquence de sous-tâches plus simples, chacune gérée par un prompt ciblé. La sortie textuelle d'une étape devient l'entrée de l'étape suivante. <strong>Exemple :</strong> Tâche 1 : extraire les entités clés d'un courriel. Tâche 2 : utiliser ces entités pour interroger une base de données. Tâche 3 : formater le résultat de la base de données en une réponse intelligible." },
                    { name: "Reflection (Producteur-Critique)", description: "Améliore la qualité par un processus itératif. Un agent 'Producteur' génère une première version de la réponse. Un agent 'Critique', avec un prompt distinct, évalue cette sortie par rapport à des critères prédéfinis (exactitude, format, ton) et fournit des commentaires. Le producteur utilise ces commentaires pour affiner sa production. Ce modèle est essentiel pour les tâches nécessitant une haute précision." },
                    { name: "Planning (Planification)", description: "Permet à un agent de transformer un objectif de haut niveau en un plan d'action structuré et exécutable. Face à une demande comme 'Organiser l'intégration d'un nouvel employé', l'agent génère d'abord une liste d'étapes (créer comptes, assigner formation, etc.) avant de les exécuter une par une, en validant le succès de chaque étape. Des modèles comme <code>ReAct (Reason+Act)</code> combinent le raisonnement et l'action à chaque étape." },
                    { name: "Tool Calling (Appel d'Outils)", description: "Le mécanisme crucial qui permet à un agent de dépasser les limites de ses connaissances internes et d'agir sur le monde réel. En invoquant des 'outils' (fonctions externes, API, requêtes SQL), l'agent peut récupérer des informations en temps réel (météo, cours de la bourse), effectuer des calculs précis, ou déclencher des actions dans des systèmes tiers (envoyer un courriel, créer un ticket). C'est ce qui transforme un modèle de langage en un agent fonctionnel." }
                ]
            },
            gouvernance: {
                title: "Gouvernance et Opérations : Introduction à l'AgentOps",
                intro: "Le déploiement à grande échelle d'agents autonomes ne peut se faire sans une discipline opérationnelle rigoureuse. Cette section introduit l'AgentOps, le framework indispensable pour gouverner l'autonomie. Nous détaillerons le cycle de vie du développement d'un agent (ADLC), l'importance de l'observabilité comportementale avec de nouveaux KPIs, et comment le Chaos Engineering est adapté pour tester la résilience des systèmes multi-agents face à des comportements émergents imprévisibles.",
                sections: [
                    {
                        subtitle: "5.1 La Nécessité d'une Nouvelle Discipline Opérationnelle",
                        content: `<p>Les disciplines existantes comme DevOps (axée sur le déploiement de code) et MLOps (axée sur le cycle de vie de modèles) sont insuffisantes pour gérer la complexité des systèmes agentiques. Un agent n'est ni un simple service, ni un simple modèle ; c'est un système composite, dynamique et non déterministe. <strong>AgentOps</strong> est le framework pour gouverner l'autonomie à grande échelle. Il se définit comme l'ensemble des pratiques de gestion du cycle de vie complet des agents IA. Sans une approche de "Gouvernance-par-la-Conception" (Governance-by-Design), un système multi-agents risque de sombrer dans le "chaos agentique" — la dégradation systémique de la cohérence due à des interactions autonomes non maîtrisées.</p>`
                    },
                    {
                        subtitle: "5.2 Le Cycle de Vie du Développement d'Agent (ADLC)",
                        content: `<p class="mb-4">L'AgentOps s'articule autour d'un cycle de vie adapté, l'Agent Development Life Cycle (ADLC), qui étend les phases traditionnelles du développement logiciel.</p>
                        <div class="flex flex-col md:flex-row items-stretch justify-center space-y-2 md:space-y-0 md:space-x-2 text-center text-sm">
                            <div class="p-3 bg-slate-800 rounded-lg flex-1 flex flex-col justify-center border border-slate-700"><strong class="block text-sky-400">1. Conception</strong>Définition des objectifs, outils, connaissances et de la "Constitution Agentique" (règles, éthique).</div>
                            <div class="text-slate-500 text-2xl font-light self-center">&rarr;</div>
                            <div class="p-3 bg-slate-800 rounded-lg flex-1 flex flex-col justify-center border border-slate-700"><strong class="block text-sky-400">2. Développement</strong>Ingénierie des prompts, codage de la logique et intégration aux outils via des API.</div>
                            <div class="text-slate-500 text-2xl font-light self-center">&rarr;</div>
                            <div class="p-3 bg-slate-800 rounded-lg flex-1 flex flex-col justify-center border border-slate-700"><strong class="block text-sky-400">3. Évaluation</strong>Tests du comportement (factualité, complétude) souvent via un LLM "juge" et des frameworks comme RAGas.</div>
                            <div class="text-slate-500 text-2xl font-light self-center">&rarr;</div>
                            <div class="p-3 bg-slate-800 rounded-lg flex-1 flex flex-col justify-center border border-slate-700"><strong class="block text-sky-400">4. Déploiement & Surveillance</strong>Déploiement et surveillance continue des performances techniques ET comportementales.</div>
                        </div>`
                    },
                    {
                        subtitle: "5.3 Observabilité Comportementale et Nouveaux Indicateurs de Performance (KPIs)",
                        content: `<p class="mb-4">Les indicateurs de performance traditionnels (temps de réponse, disponibilité, utilisation CPU) sont obsolètes pour mesurer l'efficacité de l'autonomie. AgentOps introduit de nouveaux concepts centrés sur le comportement et les résultats.</p>
                        <ul class="list-disc list-inside space-y-3">
                            <li><strong>Traces Comportementales :</strong> Pour déboguer un agent, il est essentiel de pouvoir retracer sa "pensée". Une trace capture la séquence complète : la requête initiale, la chaîne de pensée (chain of thought), chaque appel à un outil avec ses paramètres, les observations (réponses des outils), et la décision finale. Des plateformes comme LangSmith se spécialisent dans cette capture.</li>
                            <li><strong>Nouveaux KPIs orientés résultats :</strong>
                                <ul class="list-['-_'] list-inside ml-4 mt-2 space-y-1 text-slate-400">
                                    <li><strong>Taux de Réussite de la Tâche (Task Success Rate) :</strong> Pourcentage d'objectifs atteints avec succès, sans intervention humaine.</li>
                                    <li><strong>Coût par Tâche Réussie (Cost per Successful Task) :</strong> Coût total (tokens LLM, appels d'API) pour chaque tâche accomplie, permettant d'optimiser l'efficacité économique.</li>
                                    <li><strong>Niveau d'Autonomie (Autonomy Level) :</strong> Ratio d'actions autonomes par rapport aux interventions humaines (HITL), mesurant la maturité de l'agent.</li>
                                    <li><strong>Score de Factualité (Factual Consistency Score) :</strong> Mesure à quel point les réponses de l'agent sont alignées avec les sources de vérité fournies (via RAG).</li>
                                </ul>
                            </li>
                        </ul>`
                    },
                    {
                        subtitle: "5.4 Le Chaos Engineering pour les Systèmes Agentiques",
                        content: `<p>Dans les systèmes multi-agents, des comportements émergents, non explicitement programmés, peuvent apparaître. Le Chaos Engineering est la discipline qui consiste à mener des expériences contrôlées pour injecter délibérément des défaillances (pannes d'API, latence réseau, corruption de données, réponses inattendues d'outils) afin de découvrir proactivement les faiblesses du système. L'objectif est de vérifier la résilience et de découvrir des comportements émergents imprévus dans un environnement contrôlé, avant qu'ils ne provoquent une panne catastrophique en production.</p>`
                    }
                ]
            },
            horizons: {
                title: "Horizons Futurs : Informatique Quantique et Cryptographie",
                intro: "En tant qu'architectes, nous devons anticiper les futures révolutions technologiques et leurs conséquences sur les architectures que nous concevons. Cette dernière section explore l'impact potentiel de l'informatique quantique sur l'IA, mais surtout la menace existentielle qu'elle fait peser sur la sécurité actuelle. Nous aborderons la réponse cruciale qu'est la cryptographie post-quantique (PQC), soulignant la nécessité de planifier dès aujourd'hui une agilité cryptographique.",
                sections: [
                    {
                        subtitle: "6.1 L'Impact Potentiel de l'Informatique Quantique sur l'IA",
                        content: `<p>L'informatique quantique représente une rupture paradigmatique, non pas une simple accélération. En exploitant la superposition (un qubit peut représenter 0 et 1 simultanément) et l'intrication (l'état de deux qubits peut être corrélé instantanément à distance), elle promet de résoudre des problèmes inaccessibles à l'informatique classique. Son application à l'IA, bien qu'encore spéculative, est un domaine de recherche actif.</p>`
                    },
                    {
                        subtitle: "6.2 Apprentissage Automatique Quantique (QML)",
                        content: `<p>L'apprentissage automatique quantique (Quantum Machine Learning ou QML) explore comment les ordinateurs quantiques pourraient améliorer l'IA.</p>
                        <ul class="list-disc list-inside mt-2 space-y-2">
                            <li><strong>L'Astuce du Noyau Quantique (Quantum Kernel Trick) :</strong> Des algorithmes classiques comme les SVM s'appuient sur des "fonctions noyau" pour projeter les données dans un espace de plus grande dimension. Un ordinateur quantique peut calculer des noyaux dans des espaces de caractéristiques exponentiellement grands, potentiellement inaccessibles aux machines classiques, permettant de construire des classificateurs plus puissants.</li>
                            <li><strong>Réseaux de Neurones Quantiques (RNQ) :</strong> Les circuits quantiques paramétrés peuvent être entraînés de manière variationnelle, de façon similaire aux réseaux de neurones classiques, pour apprendre des motifs complexes dans les données quantiques ou classiques.</li>
                        </ul>`
                    },
                    {
                        subtitle: "6.3 La Menace Quantique pour la Sécurité et la Riposte Post-Quantique",
                        content: `<div class="p-4 bg-red-900/50 border-l-4 border-red-500 rounded-r-lg">
                            <h4 class="font-bold text-red-400 text-lg">La Menace : L'Algorithme de Shor</h4>
                            <p class="mt-1 text-slate-300">En 1994, Peter Shor a découvert un algorithme quantique capable de factoriser de très grands nombres en un temps exponentiellement plus court que les meilleurs algorithmes classiques. Un ordinateur quantique à grande échelle et tolérant aux pannes, s'il était construit, serait capable de briser la cryptographie à clé publique (RSA, ECC) qui sécurise la quasi-totalité de nos communications numériques.</p>
                        </div>
                        <div class="p-4 bg-green-900/50 border-l-4 border-green-500 rounded-r-lg mt-4">
                            <h4 class="font-bold text-green-400 text-lg">La Riposte : La Cryptographie Post-Quantique (PQC)</h4>
                            <p class="mt-1 text-slate-300">La PQC est la réponse à cette menace. Il s'agit d'une nouvelle génération d'algorithmes cryptographiques, conçus pour s'exécuter sur des ordinateurs <strong>classiques</strong>, mais qui sont mathématiquement résistants aux attaques d'ordinateurs <strong>quantiques</strong> et classiques. Des organismes comme le NIST ont mené un processus de sélection rigoureux et standardisent de nouveaux algorithmes basés sur des problèmes mathématiques différents (ex: réseaux euclidiens), tels que CRYSTALS-Kyber (pour l'échange de clés) et CRYSTALS-Dilithium (pour les signatures numériques).</p>
                        </div>
                        <p class="mt-4 text-slate-300">Pour les architectes, la menace quantique impose la nécessité de planifier une transition vers une <strong>agilité cryptographique (crypto-agility)</strong>. Cette capacité à remplacer les algorithmes d'un système sans perturber son fonctionnement est une application directe des principes de couplage lâche et de modularité qui sont au cœur de ce document.</p>`
                    }
                ]
            },
            conclusion: {
                title: "Conclusion : L'Architecte comme Concepteur d'Organismes Numériques",
                content: `
                    <p class="mb-4 text-lg text-slate-300">Ce document a tracé un chemin, de la gestion de la complexité des systèmes distribués à la délégation de l'autonomie. La transition vers l'entreprise agentique n'est pas un choix technologique parmi d'autres, mais une réponse inévitable à l'augmentation exponentielle de la dette cognitive qui paralyse nos architectures. Nous avons vu comment cette transformation s'ancre dans les principes robustes de la communication asynchrone et trouve son expression la plus puissante dans un "système nerveux" événementiel, tel qu'Apache Kafka, qui permet une coordination émergente et adaptative.</p>
                    <p class="mb-4 text-slate-400">L'avènement des agents intelligents, structurés par des modèles de conception éprouvés et gouvernés par la nouvelle discipline de l'AgentOps, marque un changement fondamental. Nous passons d'une architecture de flux de travail rigides à la culture d'un écosystème d'entités autonomes. Le rôle de l'architecte de solutions évolue en conséquence : de constructeur de machines complexes, il devient le concepteur et le "berger" d'organismes numériques vivants. Il ne définit plus le "comment", mais le "pourquoi" et les "limites".</p>
                    <p class="text-slate-300">Dans ce nouveau paradigme, la contribution humaine la plus précieuse ne réside plus dans l'écriture de la logique d'exécution, mais en amont, dans la définition de l'intention, des règles, des objectifs et de l'éthique qui animent le système dans son ensemble. L'architecte devient le gardien de la cohérence et de la finalité de cet écosystème intelligent.</p>
                `
            }
        };

        const contentContainer = document.getElementById('content-container');
        const navLinks = document.querySelectorAll('.nav-link');
        const sidebar = document.getElementById('sidebar');
        const mobileMenuButton = document.getElementById('mobile-menu-button');

        function renderContent(hash) {
            const key = hash.substring(1);
            const data = contentData[key] || contentData['introduction'];
            if (!data) return;

            let html = `<div id="${key}" class="content-section active">`;
            html += `<h1 class="text-3xl md:text-4xl font-bold text-slate-100 mb-4">${data.title}</h1>`;

            if (data.intro) {
                 html += `<div class="prose max-w-none prose-invert prose-p:text-slate-400 prose-strong:text-slate-200 mb-8 p-4 bg-slate-800 rounded-lg border border-slate-700"><p>${data.intro}</p></div>`;
            }
            
            if (data.content) {
                html += `<div class="prose max-w-none prose-invert prose-p:text-slate-400 prose-strong:text-slate-200">${data.content}</div>`;
            }

            if(data.sections) {
                data.sections.forEach(section => {
                    html += `<div class="mt-10">`;
                    if (section.subtitle) {
                        html += `<h3 class="text-2xl font-semibold text-slate-200 mb-4 pb-2 border-b border-slate-700">${section.subtitle}</h3>`;
                    }
                    html += `<div class="prose max-w-none prose-invert prose-p:text-slate-400 prose-ul:text-slate-400 prose-strong:text-slate-200">${section.content}</div>`;
                    html += `</div>`;
                });
            }

            html += `</div>`;
            contentContainer.innerHTML = html;
            
            if (key === 'paradigme' || (key === '' && hash === '#paradigme')) {
                renderParadigmChart();
            }
            
            if (data.patterns) {
                const containerId = key === 'fondations' ? 'eip-patterns' : 'agent-patterns';
                renderPatterns(containerId, data.patterns);
            }
        }
        
        function renderPatterns(containerId, patterns) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = patterns.map(p => `
                <div class="pattern-card p-4 bg-slate-800 border border-slate-700 rounded-lg shadow-sm hover:bg-slate-700/50 transition-colors">
                    <div class="flex justify-between items-center">
                        <h4 class="font-semibold text-sky-400">${p.name}</h4>
                        <span class="arrow-indicator text-sky-500 transform transition-transform duration-300">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                        </span>
                    </div>
                    <div class="pattern-detail text-sm text-slate-400 prose prose-invert prose-strong:text-slate-300">
                        <p>${p.description}</p>
                    </div>
                </div>
            `).join('');

            container.querySelectorAll('.pattern-card').forEach(card => {
                card.addEventListener('click', () => {
                    card.classList.toggle('open');
                });
            });
        }

        function updateActiveLink(hash) {
            navLinks.forEach(link => {
                if (link.getAttribute('href') === hash) {
                    link.classList.add('active');
                } else {
                    link.classList.remove('active');
                }
            });
        }
        
        function navigate() {
            let hash = window.location.hash || '#introduction';
            renderContent(hash);
            updateActiveLink(hash);
        }
        
        function renderParadigmChart() {
             const ctx = document.getElementById('paradigmChart');
             if (!ctx) return;
             new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: ['Dette Cognitive', 'Facilité d\'Innovation', 'Couplage'],
                    datasets: [
                        {
                            label: 'Monolithe',
                            data: [2.5, 1, 3], 
                            backgroundColor: 'rgba(251, 113, 133, 0.7)',
                            borderColor: 'rgba(251, 113, 133, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Microservices',
                            data: [3, 2, 1],
                            backgroundColor: 'rgba(56, 189, 248, 0.7)',
                            borderColor: 'rgba(56, 189, 248, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Agent Mesh',
                            data: [1.5, 3, 1.5],
                            backgroundColor: 'rgba(52, 211, 153, 0.7)',
                            borderColor: 'rgba(52, 211, 153, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Comparaison des Paradigmes Architecturaux (Échelle Qualitative)',
                            font: { size: 16 },
                            color: '#e2e8f0'
                        },
                        legend: {
                            labels: { color: '#94a3b8' }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    const val = context.parsed.y;
                                    if(val === 3) label += 'Très Élevé / Fort';
                                    else if(val >= 2.5) label += 'Élevé';
                                    else if(val >= 2) label += 'Moyen';
                                    else if(val >= 1.5) label += 'Faible';
                                    else if(val >= 1) label += 'Très Faible / Lâche';
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 3.5,
                            grid: { color: 'rgba(100, 116, 139, 0.3)' },
                            ticks: {
                                color: '#94a3b8',
                                callback: function(value) {
                                    if(value === 0) return 'Nul';
                                    if(value === 1) return 'Très Faible';
                                    if(value === 2) return 'Moyen';
                                    if(value === 3) return 'Très Élevé';
                                }
                            }
                        },
                        x: {
                           grid: { color: 'rgba(100, 116, 139, 0.3)' },
                           ticks: { color: '#94a3b8' }
                        }
                    }
                }
            });
        }

        window.addEventListener('hashchange', navigate);
        document.addEventListener('DOMContentLoaded', navigate);

        document.getElementById('main-nav').addEventListener('click', () => {
             if (window.innerWidth < 768) {
                sidebar.classList.add('-translate-x-full');
            }
        });
        
        mobileMenuButton.addEventListener('click', () => {
            sidebar.classList.toggle('-translate-x-full');
        });

    </script>
</body>
</html>

