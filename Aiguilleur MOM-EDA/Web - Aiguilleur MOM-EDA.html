<!DOCTYPE html>
<html lang="fr-CA">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architectures d'interopérabilité modernes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Professional Dark Theme -->
    <!-- Application Structure Plan: The application is structured as a tab-based single-page application (SPA) to transform the linear white paper into an interactive tool. This non-linear design allows technical architects to either browse a full catalog of patterns or use a guided decision-making tool ("L'Aiguilleur"). The structure includes: 1) Accueil: Introduction. 2) Paradigmes: A side-by-side comparison with an interactive chart. 3) Catalogue de Patrons: A filterable grid of cards for exploration. 4) L'Aiguilleur: A step-by-step wizard to guide selection. This task-oriented design prioritizes user workflow and decision support over static content presentation, directly addressing the source document's goal of being a practical guide. -->
    <!-- Visualization & Content Choices: Content is organized into interactive components. For comparing MOM vs. EDA, a radar chart (Chart.js on Canvas) is used to provide a quick multi-dimensional visual summary of their strengths (Goal: Compare). For organizing architectural patterns, a filterable grid of cards is used, with details revealed on click (Goal: Organize/Inform). For the core "guide" functionality, an interactive multi-step form is used to actively walk the user through the decision process (Goal: Guide Decision). Simple diagrams are built using styled HTML/Tailwind to avoid SVG/Mermaid. This approach turns passive text into an engaging, functional tool. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #030712; /* Dark Theme */
            color: #d1d5db; /* Light gray text */
        }
        .tab-active {
            border-bottom-color: #3b82f6;
            color: #3b82f6;
            font-weight: 600;
        }
        .tab-inactive {
            border-bottom-color: transparent;
            color: #9ca3bd;
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        .pattern-card {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .pattern-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .details-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }
        .details-content.open {
            max-height: 1500px;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 350px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .diagram-box {
            border: 2px solid #374151;
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: 500;
        }
        .diagram-arrow {
            position: relative;
            color: #9ca3bd;
        }
        .diagram-arrow::after {
            content: '→';
            font-size: 2rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .wizard-step {
           display: none;
        }
        .wizard-step.active {
            display: block;
        }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-100">Architectures d'interopérabilité modernes</h1>
            <p class="mt-2 text-lg text-gray-400">Guide de sélection des patrons pour la messagerie transactionnelle et les plateformes événementielles</p>
        </header>

        <nav class="mb-8 border-b border-gray-700">
            <ul class="flex flex-wrap -mb-px justify-center text-sm font-medium text-center">
                <li class="mr-2">
                    <button class="inline-block p-4 border-b-2 rounded-t-lg tab-active" data-tab="accueil">Accueil</button>
                </li>
                <li class="mr-2">
                    <button class="inline-block p-4 border-b-2 rounded-t-lg tab-inactive" data-tab="paradigmes">Paradigmes</button>
                </li>
                <li class="mr-2">
                    <button class="inline-block p-4 border-b-2 rounded-t-lg tab-inactive" data-tab="catalogue">Catalogue de Patrons</button>
                </li>
                <li class="mr-2">
                    <button class="inline-block p-4 border-b-2 rounded-t-lg tab-inactive" data-tab="aiguilleur">L'Aiguilleur</button>
                </li>
                <li>
                    <button class="inline-block p-4 border-b-2 rounded-t-lg tab-inactive" data-tab="conclusion">Conclusion</button>
                </li>
            </ul>
        </nav>

        <main>
            <section id="accueil" class="content-section active">
                <div class="bg-gray-900 p-8 rounded-lg shadow-md border border-gray-800">
                    <h2 class="text-2xl font-bold mb-4 text-blue-400">Résumé (Abstract)</h2>
                    <p class="mb-4 text-gray-300">La sélection d'une architecture d'intégration appropriée constitue une décision stratégique et structurante pour les entreprises modernes. Ce document aborde la problématique fondamentale du choix entre les paradigmes transactionnels, incarnés par les Middleware Orientés Messages (MOM) comme IBM MQ, et les paradigmes événementiels, représentés par les Architectures Orientées Événements (EDA) telles que Apache Kafka et Confluent Cloud. L'analyse se concentre sur les garanties de livraison, la gestion de l'état, la latence, la robustesse et l'évolutivité. En examinant en profondeur les patrons d'architecture spécifiques à chaque technologie, ce guide fournit un outil décisionnel rigoureux — un "aiguilleur" — destiné à aider les architectes de solutions et les décideurs techniques à sélectionner l'approche la plus pertinente pour leurs exigences fonctionnelles et non fonctionnelles, assurant ainsi l'agilité, la fiabilité et la performance de leurs systèmes d'information distribués.</p>
                    
                    <h2 class="text-2xl font-bold mb-4 mt-8 text-blue-400">Introduction</h2>
                    <h3 class="text-xl font-semibold mb-2">1.1. L'enjeu de l'interopérabilité dans l'entreprise moderne</h3>
                    <p class="mb-4 text-gray-300">Dans un écosystème technologique caractérisé par son hétérogénéité — combinant systèmes monolithiques hérités, microservices, applications SaaS et plateformes infonuagiques —, l'intégration transparente des systèmes est le pilier de la vélocité et de la transformation numérique. La capacité à décloisonner les silos de données et à orchestrer des processus métier complexes à travers des domaines technologiques distincts détermine la rapidité avec laquelle une entreprise peut innover, offrir des expériences client unifiées et exploiter l'analyse de données en temps réel. Une interopérabilité efficace n'est plus une simple nécessité technique, mais un avantage stratégique et un prérequis à la compétitivité.</p>
                    
                    <h3 class="text-xl font-semibold mb-2">1.2. La dichotomie : Messagerie vs Événements</h3>
                    <p class="mb-4 text-gray-300">Au cœur des architectures d'intégration se trouve une distinction conceptuelle fondamentale : la communication par messages (commandes) et la communication par événements (faits). La messagerie (MOM) se concentre sur l'acheminement fiable de commandes spécifiques entre des systèmes. C'est une communication intentionnelle et dirigée : un système A demande au système B d'effectuer une action (ex: "Débiter le compte X"). À l'inverse, l'architecture événementielle (EDA) se base sur la diffusion de faits (événements) qui se sont produits (ex: "Le paiement #123 a été approuvé"). Les systèmes réagissent à ces notifications de manière découplée, sans que l'émetteur ne connaisse ses destinataires. Ce document explore ces deux paradigmes à travers deux technologies de pointe : IBM MQ pour la messagerie transactionnelle garantie, et Apache Kafka pour les plateformes de traitement de flux événementiels à haute volumétrie.</p>

                    <h3 class="text-xl font-semibold mb-2">1.3. Objectif et structure du document</h3>
                    <p class="text-gray-300">Ce livre blanc a pour objectif de dépasser la simple description technologique pour offrir un guide pratique et actionnable. Il est structuré en trois parties : la première analyse les patrons fondamentaux du paradigme MOM avec IBM MQ ; la seconde explore les patrons de l'EDA avec Kafka. La troisième partie, "L'Aiguilleur Architectural", constitue l'outil central de ce document. Elle propose une méthodologie de sélection structurée pour guider l'architecte dans le choix du paradigme, du patron d'interaction et de la topologie les plus appropriés, en s'appuyant sur des cas d'utilisation concrets et des critères de décision techniques.</p>
                </div>
            </section>

            <section id="paradigmes" class="content-section">
                <div class="bg-gray-900 p-8 rounded-lg shadow-md border border-gray-800">
                    <h2 class="text-2xl font-bold text-center mb-6 text-blue-400">Comparaison des Paradigmes : MOM vs. EDA</h2>
                    <p class="text-center text-gray-400 mb-8">Cette section vise à clarifier les différences fondamentales entre la messagerie orientée message, qui est souvent utilisée pour des commandes transactionnelles, et l'architecture orientée événement, conçue pour la diffusion de faits et le traitement de flux de données en temps réel. Le graphique ci-dessous illustre visuellement leurs forces respectives à travers plusieurs axes non-fonctionnels.</p>
                    <div class="grid md:grid-cols-2 gap-8 mb-10">
                        <div class="border p-6 rounded-lg bg-gray-800 border-gray-700">
                            <h3 class="text-xl font-bold mb-3 text-blue-400">Messagerie Orientée Messages (MOM) - IBM MQ</h3>
                            <p class="mb-4 text-gray-300">Centrée sur le routage intelligent et garanti de messages discrets entre applications. Le producteur envoie un message avec une intention claire (une commande) à une destination connue, s'attendant à ce qu'une action soit effectuée de manière transactionnelle.</p>
                            <ul class="list-disc list-inside space-y-2 text-gray-300">
                                <li><strong>Fiabilité et Transactionnalité :</strong> Support natif des transactions distribuées (XA/2PC) et garantie de livraison "exactly-once" pour une intégrité absolue.</li>
                                <li><strong>Couplage Logique Faible :</strong> Les applications communiquent via des files d'attente, ignorant les détails d'implémentation mutuels, mais un couplage sémantique demeure (le producteur connaît l'intention du consommateur).</li>
                                <li><strong>Communication Dirigée et Routage Complexe :</strong> Idéal pour les commandes, les paiements, et les flux de travail nécessitant une assurance de traitement et des règles de routage avancées.</li>
                                <li><strong>Garantie d'Ordre :</strong> Assure un traitement des messages dans l'ordre strict de leur arrivée au sein d'une file.</li>
                                <li><strong>Modèle :</strong> "Smart pipes, dumb endpoints". Le middleware est intelligent (routage, transactions), les applications sont plus simples.</li>
                            </ul>
                        </div>
                        <div class="border p-6 rounded-lg bg-gray-800 border-gray-700">
                            <h3 class="text-xl font-bold mb-3 text-purple-400">Architecture Orientée Événements (EDA) - Kafka</h3>
                            <p class="mb-4 text-gray-300">Centrée sur la diffusion de faits immuables (événements) dans un journal de transactions distribué et persistant. Le producteur publie un événement sans connaître les consommateurs, qui sont libres de s'abonner et de réagir de manière indépendante.</p>
                            <ul class="list-disc list-inside space-y-2 text-gray-300">
                                <li><strong>Haute Volumétrie et Persistance :</strong> Conçu pour ingérer et stocker des milliards d'événements de manière durable et réplicable. Le journal est la source de vérité.</li>
                                <li><strong>Découplage Temporel et Logique :</strong> Les consommateurs peuvent traiter les événements à leur propre rythme, et relire l'historique ("replayability"). Le producteur ignore totalement l'existence et la nature des consommateurs.</li>
                                <li><strong>Traitement de Flux (Stream Processing) :</strong> Écosystème riche (Kafka Streams, ksqlDB) pour des analyses, des agrégations et des transformations en temps réel sur les flux d'événements.</li>
                                <li><strong>Évolutivité Horizontale :</strong> Le modèle de partitions permet une mise à l'échelle quasi linéaire des producteurs et des consommateurs.</li>
                                <li><strong>Modèle :</strong> "Dumb pipes, smart endpoints". Le broker est un simple journal, l'intelligence de traitement est déportée dans les consommateurs.</li>
                            </ul>
                        </div>
                    </div>
                     <div class="chart-container">
                        <canvas id="paradigmChart"></canvas>
                    </div>
                </div>
            </section>
            
            <section id="catalogue" class="content-section">
                 <div class="bg-gray-900 p-8 rounded-lg shadow-md border border-gray-800">
                    <h2 class="text-2xl font-bold text-center mb-4 text-blue-400">Catalogue de Patrons d'Architecture</h2>
                    <p class="text-center text-gray-400 mb-8">Explorez les différents patrons d'architecture pour IBM MQ et Kafka. Chaque patron est conçu pour résoudre des problèmes d'intégration spécifiques. Utilisez les filtres pour affiner votre recherche et cliquez sur une carte pour voir les détails, l'implémentation, les cas d'utilisation pertinents, ainsi que leurs avantages et inconvénients.</p>
                    <div class="flex justify-center flex-wrap gap-2 mb-8" id="filter-buttons">
                        <button class="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50" data-filter="all">Tous</button>
                        <button class="px-4 py-2 text-sm font-medium text-gray-300 bg-gray-700 rounded-lg hover:bg-gray-600 focus:outline-none" data-filter="mq">IBM MQ</button>
                        <button class="px-4 py-2 text-sm font-medium text-gray-300 bg-gray-700 rounded-lg hover:bg-gray-600 focus:outline-none" data-filter="kafka">Kafka</button>
                    </div>
                    <div id="patterns-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    </div>
                </div>
            </section>
            
            <section id="aiguilleur" class="content-section">
                <div class="bg-gray-900 p-8 rounded-lg shadow-md border border-gray-800">
                    <h2 class="text-2xl font-bold text-center mb-4 text-blue-400">L'Aiguilleur Architectural</h2>
                    <p class="text-center text-gray-400 mb-8">Cet outil interactif vous guide dans le choix du paradigme et des patrons les plus adaptés à vos besoins. Répondez aux questions suivantes pour obtenir une recommandation architecturale basée sur les principes décrits dans ce document.</p>
                    
                    <div id="wizard-container" class="space-y-8">
                        <div id="step1-container" class="wizard-step active">
                            <h3 class="text-lg font-semibold mb-3">Étape 1 : Définir le paradigme principal (MOM vs EDA)</h3>
                            <p class="text-sm text-gray-400 mb-4">Quelle est la nature fondamentale de l'interaction ? S'agit-il d'une commande qui attend une action spécifique et garantie, ou d'un fait qui notifie un changement d'état à un nombre inconnu de systèmes intéressés ?</p>
                            <div class="space-y-2" id="step1">
                                <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                                    <input type="radio" name="paradigm" value="mom" class="h-4 w-4 text-blue-600 border-gray-600 focus:ring-blue-500 bg-gray-700">
                                    <span class="ml-3 text-gray-300"><strong>Commande/Transaction (MOM) :</strong> Le système A demande au système B d'exécuter une tâche critique (ex: traiter un paiement, créer un ordre). L'intégrité transactionnelle et la garantie de traitement sont non-négociables.</span>
                                </label>
                                <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                                    <input type="radio" name="paradigm" value="eda" class="h-4 w-4 text-purple-600 border-gray-600 focus:ring-purple-500 bg-gray-700">
                                    <span class="ml-3 text-gray-300"><strong>Fait/Notification (EDA) :</strong> Un événement s'est produit (ex: un utilisateur a cliqué, une commande a été expédiée). L'objectif est de diffuser cette information à haute volumétrie et de permettre à divers systèmes de réagir de manière découplée, en temps réel ou en différé.</span>
                                </label>
                            </div>
                        </div>

                        <div id="step2-container" class="wizard-step">
                            <h3 class="text-lg font-semibold mb-3">Étape 2 : Qualifier le modèle d'interaction</h3>
                            <p class="text-sm text-gray-400 mb-4">Comment les applications doivent-elles communiquer entre elles ?</p>
                            <div class="space-y-2" id="step2">
                            </div>
                        </div>

                         <div id="step3-container" class="wizard-step">
                            <h3 class="text-lg font-semibold mb-3">Étape 3 : Évaluer les exigences de cohérence et de gestion de l'état</h3>
                            <p class="text-sm text-gray-400 mb-4">Avez-vous besoin de reconstruire l'état d'une entité à partir de son historique ou de gérer des transactions métier complexes sur plusieurs services ?</p>
                            <div class="space-y-2" id="step3">
                            </div>
                        </div>
                        
                        <div id="step4-container" class="wizard-step">
                            <h3 class="text-lg font-semibold mb-3">Étape 4 : Définir la topologie et les exigences non-fonctionnelles</h3>
                            <p class="text-sm text-gray-400 mb-4">Quelles sont vos contraintes de haute disponibilité, de performance et d'évolutivité ?</p>
                            <div class="space-y-2" id="step4">
                            </div>
                        </div>

                        <div id="recommendation-container" class="hidden mt-8 p-6 bg-gray-800 border border-blue-800 rounded-lg">
                            <h3 class="text-xl font-bold text-blue-400 mb-3">Patrons recommandés</h3>
                            <p class="text-blue-300 mb-4">En fonction de vos sélections, voici les patrons d'architecture les plus pertinents pour votre cas d'utilisation :</p>
                            <div id="recommendation-list" class="space-y-2"></div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="conclusion" class="content-section">
                <div class="bg-gray-900 p-8 rounded-lg shadow-md border border-gray-800">
                    <h2 class="text-2xl font-bold mb-4 text-blue-400">Conclusion et Perspectives</h2>
                    <h3 class="text-xl font-semibold mb-2">5.1. Synthèse : Choisir le bon outil pour le bon travail</h3>
                    <p class="mb-4 text-gray-300">La sélection d'une technologie d'intégration ne doit pas être une décision dogmatique en faveur d'une tendance, mais une analyse architecturale rigoureuse des besoins métiers et techniques. IBM MQ excelle dans les scénarios exigeant une fiabilité transactionnelle absolue, une intégrité des données irréprochable et une communication dirigée, typiques des systèmes financiers, des télécommunications et des processus critiques d'entreprise. Apache Kafka, quant à lui, est le choix privilégié pour les architectures nécessitant une ingestion massive de données, un traitement de flux en temps réel, une évolutivité horizontale et un découplage temporel complet, comme dans l'IoT, l'analyse comportementale et les écosystèmes de microservices modernes. L'objectif est d'aligner les exigences du problème avec les forces intrinsèques de la solution.</p>
                    
                    <h3 class="text-xl font-semibold mb-2">5.2. Vers des architectures hybrides</h3>
                    <p class="mb-4 text-gray-300">La dichotomie entre messagerie et événements n'est pas absolue. Les architectures les plus robustes et évolutives sont souvent hybrides, exploitant la synergie des deux paradigmes. Il est tout à fait plausible, et même recommandé, de les combiner pour capitaliser sur leurs forces respectives. Par exemple, une plateforme Kafka peut être utilisée pour agréger et analyser des millions d'événements en temps réel (suivi de clics, données de capteurs), puis générer une commande synthétique et qualifiée (ex: "Déclencher une transaction de remboursement pour le client X"). Cette commande peut ensuite être injectée de manière atomique dans un système IBM MQ pour garantir son traitement transactionnel et fiable par le système de facturation ou le système central (mainframe). Cette synergie tire parti du meilleur des deux mondes : l'évolutivité et l'analyse de Kafka, et la robustesse transactionnelle de MQ.</p>
                     <div class="my-6">
                        <div class="flex flex-wrap items-center justify-center gap-2 text-sm text-center">
                           <div class="diagram-box">Plateforme IoT / Web</div>
                           <div class="diagram-arrow w-12 h-16"></div>
                           <div class="diagram-box">Kafka<br><span class="text-xs font-normal text-gray-400">(Ingestion, Analyse de flux)</span></div>
                           <div class="diagram-arrow w-12 h-16"></div>
                           <div class="diagram-box">Processeur d'Événements</div>
                           <div class="diagram-arrow w-12 h-16"></div>
                           <div class="diagram-box">IBM MQ<br><span class="text-xs font-normal text-gray-400">(Transaction garantie)</span></div>
                           <div class="diagram-arrow w-12 h-16"></div>
                           <div class="diagram-box">Système Central / ERP</div>
                        </div>
                    </div>
                     <h3 class="text-xl font-semibold mb-2">5.3. Perspectives d'avenir</h3>
                    <p class="text-gray-300">L'avenir des architectures d'intégration réside dans une abstraction accrue, une gouvernance unifiée et une interopérabilité transparente entre ces différents paradigmes. L'émergence de standards comme AsyncAPI pour la description des interfaces événementielles, l'intégration plus poussée des plateformes dans les maillages de services (service mesh), et le développement d'outils de gouvernance centralisée (ex: Confluent Schema Registry pour Kafka) sont des tendances clés. Ces évolutions visent à simplifier la complexité pour les développeurs tout en fournissant aux architectes la visibilité et le contrôle nécessaires pour gérer des écosystèmes distribués de plus en plus sophistiqués.</p>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const tabs = document.querySelectorAll('nav button');
            const sections = document.querySelectorAll('.content-section');
            const patternsGrid = document.getElementById('patterns-grid');
            const filterButtonsContainer = document.getElementById('filter-buttons');

            const patternsData = [
                {
                    category: 'mq',
                    type: 'communication',
                    title: 'Point à Point (File d\'attente)',
                    description: 'Un émetteur envoie un message à une file d\'attente spécifique, et un seul récepteur désigné consomme ce message de manière atomique.',
                    implementation: 'Implémenté via des objets `Queue`. L\'émetteur utilise `MQPUT` pour déposer un message et le récepteur utilise `MQGET` avec une option de synchronisation (`syncpoint`) pour le récupérer. Le message n\'est définitivement retiré de la file qu\'après un `MQCMIT` (commit) réussi, garantissant le traitement. En cas d\'échec, un `MQBACK` (rollback) le rend de nouveau disponible.',
                    use_cases: '<strong>Traitement des Ordres de Bourse :</strong> Un ordre est placé dans une file pour être traité de manière unique et garantie par un moteur de trading. <strong>Paiements Bancaires :</strong> Une transaction de paiement est envoyée à une file pour être traitée de manière fiable et sans duplication par le système central.',
                    pros: ['Garantie de traitement unique', 'Fiabilité transactionnelle élevée', 'Simplicité conceptuelle'],
                    cons: ['Couplage fort au destinataire logique', 'Pas de diffusion d\'information', 'Scalabilité des consommateurs limitée']
                },
                {
                    category: 'mq',
                    type: 'communication',
                    title: 'Publication/Abonnement',
                    description: 'Un émetteur (publisher) envoie un message à un sujet (topic), et tous les abonnés (subscribers) intéressés par ce sujet reçoivent une copie du message.',
                    implementation: 'Utilise des objets `Topic` gérés par le gestionnaire de files. Les applications s\'abonnent à une chaîne de sujet. Les abonnements durables (`Durable Subscriptions`) permettent de recevoir les messages publiés même si l\'abonné était déconnecté, assurant qu\'aucune information n\'est perdue.',
                    use_cases: '<strong>Système de Paiements :</strong> Diffusion interne des changements d\'état d\'un paiement (ex: "Accepté", "Refusé") à plusieurs systèmes intéressés simultanément (surveillance, notification, audit).',
                    pros: ['Découplage complet entre émetteur et récepteurs', 'Diffusion d\'information à grande échelle', 'Flexibilité (ajout facile de nouveaux abonnés)'],
                    cons: ['Pas de garantie de traitement (le producteur ne sait pas qui a traité)', 'Gestion de l\'état des abonnements plus complexe']
                },
                {
                    category: 'mq',
                    type: 'communication',
                    title: 'Requête/Réponse',
                    description: 'Un demandeur envoie un message de requête et attend une réponse corrélée sur une file d\'attente de réponse dédiée, simulant une communication synchrone sur une infrastructure asynchrone.',
                    implementation: 'L\'en-tête du message de requête contient les champs `ReplyToQ` (nom de la file de réponse) et `CorrelationID` (un identifiant unique). Le répondeur place la réponse dans la `ReplyToQ` avec le même `CorrelationID`, permettant au demandeur de faire correspondre sans ambiguïté la réponse à sa requête initiale.',
                    use_cases: '<strong>Traitement des Ordres de Bourse :</strong> Une application front-end envoie une requête de validation de solde et attend une réponse de confirmation avant de soumettre l\'ordre final.',
                    pros: ['Permet des interactions synchrones', 'Corrélation des messages intégrée au protocole', 'Simple à implémenter pour des interactions client-serveur'],
                    cons: ['Crée un couplage temporel (le demandeur attend)', 'Gestion des timeouts nécessaire', 'Peut devenir un goulot d\'étranglement']
                },
                {
                    category: 'mq',
                    type: 'topology',
                    title: 'Cluster IBM MQ',
                    description: 'Groupe de gestionnaires de files d\'attente (Queue Managers) qui partagent des informations de configuration pour simplifier l\'administration, permettre la répartition de charge et la haute disponibilité.',
                    implementation: 'Au moins deux gestionnaires de files sont désignés comme "Full Repositories" et maintiennent une vue complète de la topologie du cluster. Les autres membres ("Partial Repositories") les contactent pour obtenir les informations de routage. Une application peut se connecter à n\'importe quel membre pour envoyer un message à une file hébergée sur un autre membre, sans nécessiter de définition de canaux manuelle.',
                    use_cases: '<strong>Traitement des Ordres de Bourse :</strong> Permet aux applications de trading de se connecter au gestionnaire de files le plus proche ou le plus disponible, tout en accédant aux files de traitement qui peuvent être hébergées ailleurs dans le cluster pour la résilience et la répartition de charge.',
                    pros: ['Administration simplifiée', 'Répartition de charge automatique', 'Haute disponibilité de la connectivité'],
                    cons: ['Complexité de la configuration initiale', 'Le partage de la charge ne signifie pas partage des données de files']
                },
                {
                    category: 'mq',
                    type: 'topology',
                    title: 'Gestionnaires de files multi-instances (HA)',
                    description: 'Architecture actif/passif pour la haute disponibilité. Une instance active traite les messages tandis qu\'une instance passive est en attente, prête à prendre le relais en cas de défaillance.',
                    implementation: 'Nécessite un stockage réseau partagé et hautement disponible (ex: NFSv4, SAN) où les journaux et les données des files sont stockés. Les deux instances partagent la même configuration. En cas de panne de l\'instance active, le verrou sur les fichiers est libéré, et l\'instance passive prend le contrôle du stockage, redémarre le service et reprend le traitement là où il s\'est arrêté.',
                    use_cases: '<strong>Paiements Bancaires et Ordres de Bourse :</strong> Crucial pour les systèmes critiques qui ne peuvent tolérer aucune perte de message et nécessitent un temps de récupération (RTO) très court en cas de défaillance matérielle ou logicielle.',
                    pros: ['Haute disponibilité robuste', 'Pas de perte de données (RPO de zéro)', 'Relativement simple à configurer'],
                    cons: ['Dépendance à un stockage réseau partagé (SPOF potentiel)', 'Modèle actif/passif (ressources passives en attente)']
                },
                 {
                    category: 'mq',
                    type: 'topology',
                    title: 'Native HA pour conteneurs',
                    description: 'Un groupe de trois gestionnaires de files fonctionnant en mode actif/actif pour la haute disponibilité des données, spécialement conçu pour les environnements conteneurisés comme Kubernetes.',
                    implementation: 'Ce patron utilise un protocole de réplication de journal basé sur Raft. Les trois instances répliquent les journaux de transactions entre elles. Une seule instance est le leader actif à un instant T, mais en cas de défaillance, un nouveau leader est élu en quelques secondes. Contrairement à la HA multi-instances, il ne nécessite pas de stockage partagé spécialisé, chaque pod utilisant son propre stockage persistant (PVC).',
                    use_cases: '<strong>Système de Paiements Bancaires modernisé sur Kubernetes :</strong> Fournit une haute disponibilité sans les contraintes d\'un système de fichiers partagé, s\'intégrant nativement dans l\'écosystème des conteneurs.',
                    pros: ['Pas de dépendance à un stockage partagé', 'Failover rapide et automatique', 'Conçu pour le cloud et Kubernetes'],
                    cons: ['Nécessite trois instances (coût en ressources)', 'Latence de réplication synchrone à prendre en compte']
                },
                {
                    category: 'kafka',
                    type: 'event',
                    title: 'Approvisionnement en Événements (Event Sourcing)',
                    description: 'L\'état d\'une application ou d\'une entité est stocké non pas comme un état final, mais comme une séquence chronologique et immuable d\'événements.',
                    implementation: 'Kafka est le magasin d\'événements (Event Store) idéal. Chaque changement d\'état est publié comme un événement dans un topic Kafka, partitionné par l\'ID de l\'entité pour garantir l\'ordre. Pour reconstruire l\'état actuel, un service relit tous les événements de cette entité depuis le début. Les snapshots périodiques peuvent optimiser le temps de reconstruction.',
                    use_cases: '<strong>Suivi de Commandes E-commerce :</strong> L\'historique complet d\'une commande ("Créée", "Payée", "Expédiée", "Livrée") est stocké comme une série d\'événements. Cela permet un audit complet, des analyses temporelles et la reconstruction de l\'état à n\'importe quel moment.',
                    pros: ['Auditabilité complète et traçabilité', 'Permet de dériver de multiples modèles de lecture', 'Découplage temporel puissant'],
                    cons: ['Complexité de la reconstruction d\'état', 'Gestion de l\'évolution des schémas d\'événements (versioning)']
                },
                {
                    category: 'kafka',
                    type: 'event',
                    title: 'CQRS (Command Query Responsibility Segregation)',
                    description: 'Séparation architecturale des modèles de données et des logiques pour l\'écriture (Commandes) et la lecture (Requêtes), souvent utilisé avec l\'Event Sourcing.',
                    implementation: 'Les commandes (écritures) sont traitées et génèrent des événements stockés dans Kafka. Des processeurs de flux (Kafka Streams, ksqlDB) consomment ces événements en temps réel pour créer et maintenir des vues matérialisées (modèles de lecture) optimisées pour les requêtes, stockées dans des bases de données de lecture appropriées (ex: Elasticsearch, PostgreSQL, Redis).',
                    use_cases: '<strong>Suivi de Commandes E-commerce :</strong> Le modèle d\'écriture gère la logique complexe des commandes, tandis que des vues de lecture optimisées sont créées pour afficher rapidement les listes de commandes par client, les statuts, et les tableaux de bord analytiques.',
                    pros: ['Optimisation indépendante des lectures et écritures', 'Évolutivité améliorée pour chaque côté', 'Flexibilité des modèles de données de lecture'],
                    cons: ['Complexité architecturale accrue', 'Latence de cohérence à terme ("eventual consistency") entre l\'écriture et la lecture']
                },
                {
                    category: 'kafka',
                    type: 'event',
                    title: 'Saga',
                    description: 'Gestion de transactions métier qui s\'étendent sur plusieurs services distribués. Une Saga est une séquence de transactions locales où chaque transaction met à jour un service et publie un événement pour déclencher la transaction suivante.',
                    implementation: '<strong>Chorégraphie :</strong> Les services s\'abonnent aux événements les uns des autres pour déclencher l\'étape suivante. C\'est une approche décentralisée. <strong>Orchestration :</strong> Un orchestrateur central écoute les événements et envoie des commandes explicites aux services. Kafka sert de bus de communication fiable pour les événements (chorégraphie) ou les commandes/événements (orchestration). Des transactions de compensation sont prévues en cas d\'échec d\'une étape.',
                    use_cases: '<strong>Système de Suivi des Commandes E-commerce :</strong> Le processus de commande (Paiement, Inventaire, Expédition) est une Saga. Le service de paiement publie "Paiement Réussi", le service d\'inventaire réagit et publie "Articles Réservés", et ainsi de suite. Si l\'expédition échoue, des événements de compensation annulent la réservation et remboursent le paiement.',
                    pros: ['Maintient la cohérence des données sur plusieurs services', 'Évite les transactions distribuées bloquantes (2PC)', 'Améliore la résilience'],
                    cons: ['Complexité de conception (surtout pour les compensations)', 'Difficulté de débogage et de suivi de l\'état global']
                },
                {
                    category: 'kafka',
                    type: 'resilience',
                    title: 'Publication/Abonnement en Éventail (Fan-out)',
                    description: 'Un seul événement publié dans un topic peut être consommé indépendamment et en parallèle par plusieurs services ou applications ayant des logiques métier distinctes.',
                    implementation: 'Chaque service qui a besoin de consommer les événements d\'un topic utilise son propre `group.id` (groupe de consommateurs). Kafka garantit que chaque message est livré à un seul consommateur au sein d\'un groupe, mais le même message est livré à un représentant de chaque groupe. Ainsi, plusieurs groupes peuvent traiter le même flux d\'événements pour des objectifs différents (ex: un groupe pour la notification, un autre pour l\'archivage).',
                    use_cases: '<strong>Suivi de Commandes E-commerce :</strong> Un événement "Commande Créée" est consommé par le groupe "notifications", le groupe "fraude" et le groupe "analytics", chacun travaillant indépendamment et à son propre rythme.',
                    pros: ['Découplage maximal des consommateurs', 'Évolutivité indépendante de chaque service consommateur', 'Traitement parallèle pour différents cas d\'usage'],
                    cons: ['Augmentation potentielle de la charge sur les brokers si de nombreux groupes consomment']
                },
                {
                    category: 'kafka',
                    type: 'resilience',
                    title: 'File de Messages non Traitables (Dead Letter Queue)',
                    description: 'Patron de résilience pour isoler et gérer les messages qui ne peuvent pas être traités avec succès après plusieurs tentatives, afin de ne pas bloquer le traitement principal.',
                    implementation: 'Dans le consommateur, un bloc `try-catch` entoure la logique de traitement. En cas d\'échec persistant, le consommateur cesse de réessayer et publie le message problématique dans un topic séparé, la "Dead Letter Queue" (DLQ), en y ajoutant des en-têtes contenant des informations sur l\'erreur (stack trace, service, timestamp).',
                    use_cases: '<strong>Plateforme IoT :</strong> Si une lecture de capteur est malformée (ex: JSON invalide) et ne peut être parsée, elle est envoyée à une DLQ pour une analyse manuelle ou automatisée, sans interrompre le flux de données valides.',
                    pros: ['Empêche le blocage des partitions ("poison pill")', 'Isole les messages problématiques pour analyse', 'Améliore la robustesse globale du système'],
                    cons: ['Nécessite une logique supplémentaire dans le consommateur', 'Nécessite un processus de surveillance et de gestion de la DLQ']
                }
            ];

            function renderPatterns(filter = 'all') {
                patternsGrid.innerHTML = '';
                const filteredPatterns = patternsData.filter(p => filter === 'all' || p.category === filter);

                if (filteredPatterns.length === 0) {
                    patternsGrid.innerHTML = `<p class="text-gray-500 col-span-full text-center">Aucun patron ne correspond à ce filtre.</p>`;
                    return;
                }

                filteredPatterns.forEach(pattern => {
                    const card = document.createElement('div');
                    card.className = `pattern-card border rounded-lg p-5 cursor-pointer bg-gray-800 ${pattern.category === 'mq' ? 'border-blue-800' : 'border-purple-800'}`;
                    card.innerHTML = `
                        <div class="flex justify-between items-start">
                            <h3 class="text-xl font-bold mb-2 ${pattern.category === 'mq' ? 'text-blue-400' : 'text-purple-400'}">${pattern.title}</h3>
                            <span class="text-xs font-semibold uppercase px-2 py-1 rounded-full ${pattern.category === 'mq' ? 'bg-blue-900 text-blue-300' : 'bg-purple-900 text-purple-300'}">${pattern.category}</span>
                        </div>
                        <p class="text-gray-400 mb-4 text-sm">${pattern.description}</p>
                        <div class="details-content">
                            <h4 class="font-semibold mt-4 mb-2 text-gray-200">Implémentation</h4>
                            <p class="text-sm text-gray-400 mb-4">${pattern.implementation}</p>
                            <h4 class="font-semibold mt-4 mb-2 text-gray-200">Cas d'utilisation</h4>
                            <p class="text-sm text-gray-400 mb-4">${pattern.use_cases}</p>
                            <div class="grid grid-cols-2 gap-4 mt-4 text-sm">
                                <div>
                                    <h5 class="font-semibold text-green-400 mb-1">Avantages</h5>
                                    <ul class="list-disc list-inside text-gray-400 space-y-1">${pattern.pros.map(p => `<li>${p}</li>`).join('')}</ul>
                                </div>
                                <div>
                                    <h5 class="font-semibold text-red-400 mb-1">Inconvénients</h5>
                                    <ul class="list-disc list-inside text-gray-400 space-y-1">${pattern.cons.map(c => `<li>${c}</li>`).join('')}</ul>
                                </div>
                            </div>
                        </div>
                    `;
                    card.addEventListener('click', () => {
                        card.querySelector('.details-content').classList.toggle('open');
                    });
                    patternsGrid.appendChild(card);
                });
            }

            filterButtonsContainer.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    document.querySelector('#filter-buttons button.bg-blue-600').classList.replace('bg-blue-600', 'bg-gray-700');
                    document.querySelector('#filter-buttons button.text-white').classList.replace('text-white', 'text-gray-300');
                    e.target.classList.replace('bg-gray-700', 'bg-blue-600');
                    e.target.classList.replace('text-gray-300', 'text-white');
                    renderPatterns(e.target.dataset.filter);
                }
            });

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.replace('tab-active', 'tab-inactive'));
                    sections.forEach(s => s.classList.remove('active'));

                    tab.classList.replace('tab-inactive', 'tab-active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                });
            });
            
            const paradigmCtx = document.getElementById('paradigmChart').getContext('2d');
            new Chart(paradigmCtx, {
                type: 'radar',
                data: {
                    labels: ['Fiabilité Transactionnelle', 'Haute Volumétrie', 'Traitement de Flux', 'Couplage Temporel', 'Communication Dirigée', 'Persistance Long Terme'],
                    datasets: [{
                        label: 'IBM MQ (MOM)',
                        data: [6, 3, 2, 3, 6, 4],
                        fill: true,
                        backgroundColor: 'rgba(59, 130, 246, 0.2)',
                        borderColor: 'rgb(59, 130, 246)',
                        pointBackgroundColor: 'rgb(59, 130, 246)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgb(59, 130, 246)'
                    }, {
                        label: 'Kafka (EDA)',
                        data: [4, 6, 6, 6, 3, 6],
                        fill: true,
                        backgroundColor: 'rgba(168, 85, 247, 0.2)',
                        borderColor: 'rgb(168, 85, 247)',
                        pointBackgroundColor: 'rgb(168, 85, 247)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgb(168, 85, 247)'
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    elements: {
                        line: {
                            borderWidth: 3
                        }
                    },
                    scales: {
                        r: {
                            angleLines: {
                                display: true,
                                color: 'rgba(255, 255, 255, 0.2)'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.2)'
                            },
                            suggestedMin: 0,
                            suggestedMax: 6,
                            pointLabels: {
                                font: {
                                    size: 11
                                },
                                color: '#d1d5db'
                            }
                        }
                    },
                     plugins: {
                        legend: {
                            labels: {
                                color: '#d1d5db'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    const value = context.raw;
                                    const scale = ['N/A', 'Très Faible', 'Faible', 'Moyen', 'Bon', 'Excellent', 'Exceptionnel'];
                                    label += scale[value];
                                    return label;
                                }
                            }
                        }
                    }
                }
            });

            renderPatterns();

            const wizardState = {};
            const wizardSteps = document.querySelectorAll('.wizard-step');
            const step1Container = document.getElementById('step1-container');
            const step1 = document.getElementById('step1');
            const step2Container = document.getElementById('step2-container');
            const step2Div = document.getElementById('step2');
            const step3Container = document.getElementById('step3-container');
            const step3Div = document.getElementById('step3');
            const step4Container = document.getElementById('step4-container');
            const step4Div = document.getElementById('step4');
            const recommendationContainer = document.getElementById('recommendation-container');
            const recommendationList = document.getElementById('recommendation-list');

            function showStep(stepId) {
                wizardSteps.forEach(step => {
                    if (step.id === stepId) {
                        step.classList.add('active');
                    } else {
                        step.classList.remove('active');
                    }
                });
            }

            const step2Options = {
                mom: `
                    <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="interaction" value="p2p" class="h-4 w-4 text-blue-600 border-gray-600 focus:ring-blue-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>Point à Point :</strong> Une commande doit être traitée par un et un seul consommateur.</span>
                    </label>
                    <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="interaction" value="pubsub" class="h-4 w-4 text-blue-600 border-gray-600 focus:ring-blue-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>Publication/Abonnement :</strong> Une information (ex: un changement de statut) doit être diffusée à plusieurs systèmes internes connus.</span>
                    </label>
                    <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="interaction" value="reqres" class="h-4 w-4 text-blue-600 border-gray-600 focus:ring-blue-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>Requête/Réponse :</strong> Une application envoie une requête et attend une réponse corrélée de manière asynchrone.</span>
                    </label>
                `,
                eda: `
                    <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="interaction" value="fanout" class="h-4 w-4 text-purple-600 border-gray-600 focus:ring-purple-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>Diffusion en Éventail (Fan-out) :</strong> Un événement doit être traité indépendamment par plusieurs domaines fonctionnels différents (ex: notification, analyse, archivage).</span>
                    </label>
                `
            };
            
            const step3Options = {
                eda: `
                    <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="consistency" value="eventsourcing" class="h-4 w-4 text-purple-600 border-gray-600 focus:ring-purple-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>Oui, l'historique est la source de vérité (Event Sourcing) :</strong> Je dois pouvoir reconstruire l'état d'une entité (ex: commande) en relisant toute son histoire. L'auditabilité est primordiale.</span>
                    </label>
                     <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="consistency" value="saga" class="h-4 w-4 text-purple-600 border-gray-600 focus:ring-purple-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>Oui, pour des transactions métier distribuées (Saga) :</strong> J'ai besoin de coordonner une transaction métier sur plusieurs microservices qui peuvent prendre du temps ou échouer indépendamment.</span>
                    </label>
                    <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="consistency" value="none" class="h-4 w-4 text-purple-600 border-gray-600 focus:ring-purple-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>Non :</strong> Mes besoins en gestion d'état sont simples ou gérés au sein de chaque service.</span>
                    </label>
                `
            };
            
            const step4Options = {
                mom: `
                    <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="topology" value="multii" class="h-4 w-4 text-blue-600 border-gray-600 focus:ring-blue-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>HA Actif/Passif :</strong> La haute disponibilité est critique, avec un RPO de zéro, et je dispose d'un stockage partagé.</span>
                    </label>
                    <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="topology" value="nativeha" class="h-4 w-4 text-blue-600 border-gray-600 focus:ring-blue-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>HA Native pour Conteneurs :</strong> Mon infrastructure est sur Kubernetes et je souhaite une HA robuste sans dépendance à un stockage partagé.</span>
                    </label>
                    <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="topology" value="cluster" class="h-4 w-4 text-blue-600 border-gray-600 focus:ring-blue-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>Évolutivité et répartition de charge :</strong> J'ai besoin de distribuer la charge de connexion et de simplifier l'administration sur plusieurs serveurs.</span>
                    </label>
                `,
                eda: `
                     <label class="flex items-center p-3 border rounded-lg hover:bg-gray-800 cursor-pointer border-gray-700">
                        <input type="radio" name="topology" value="default" class="h-4 w-4 text-purple-600 border-gray-600 focus:ring-purple-500 bg-gray-700">
                        <span class="ml-3 text-gray-300"><strong>Évolutivité horizontale maximale :</strong> Mon besoin principal est de gérer une très haute volumétrie et de permettre aux consommateurs de monter en charge indépendamment. La résilience est assurée par la réplication native de Kafka.</span>
                    </label>
                `
            };

            step1.addEventListener('change', e => {
                wizardState.paradigm = e.target.value;
                step2Div.innerHTML = step2Options[wizardState.paradigm];
                
                delete wizardState.interaction;
                delete wizardState.consistency;
                delete wizardState.topology;
                
                showStep('step2-container');
                updateRecommendation();
            });

            step2Div.addEventListener('change', e => {
                wizardState.interaction = e.target.value;
                 if(wizardState.paradigm === 'eda'){
                    step3Div.innerHTML = step3Options.eda;
                    showStep('step3-container');
                } else {
                    step4Div.innerHTML = step4Options.mom;
                    showStep('step4-container');
                }
                updateRecommendation();
            });
            
             step3Div.addEventListener('change', e => {
                wizardState.consistency = e.target.value;
                step4Div.innerHTML = step4Options.eda;
                showStep('step4-container');
                updateRecommendation();
            });
            
             step4Div.addEventListener('change', e => {
                wizardState.topology = e.target.value;
                updateRecommendation();
            });

            function updateRecommendation() {
                let recommendations = [];
                if (wizardState.paradigm === 'mom') {
                    if (wizardState.interaction === 'p2p') recommendations.push('Point à Point (File d\'attente)');
                    if (wizardState.interaction === 'pubsub') recommendations.push('Publication/Abonnement');
                    if (wizardState.interaction === 'reqres') recommendations.push('Requête/Réponse');
                    
                    if (wizardState.topology === 'multii') recommendations.push('Gestionnaires de files multi-instances (HA)');
                    if (wizardState.topology === 'nativeha') recommendations.push('Native HA pour conteneurs');
                    if (wizardState.topology === 'cluster') recommendations.push('Cluster IBM MQ');

                } else if (wizardState.paradigm === 'eda') {
                    if (wizardState.interaction === 'fanout') {
                        recommendations.push('Publication/Abonnement en Éventail (Fan-out)');
                        recommendations.push('File de Messages non Traitables (Dead Letter Queue) pour la résilience');
                    }
                    if(wizardState.consistency === 'eventsourcing') {
                        recommendations.push('Approvisionnement en Événements (Event Sourcing)');
                        recommendations.push('CQRS pour optimiser les lectures');
                    }
                     if(wizardState.consistency === 'saga') {
                        recommendations.push('Saga (par chorégraphie ou orchestration)');
                    }
                }

                if (recommendations.length > 0) {
                    recommendationList.innerHTML = recommendations.map(r => `<div class="p-3 bg-gray-700 rounded shadow-sm text-gray-200">${r}</div>`).join('');
                    recommendationContainer.classList.remove('hidden');
                } else {
                    recommendationContainer.classList.add('hidden');
                }
            }

        });
    </script>

</body>
</html>

